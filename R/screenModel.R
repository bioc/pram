#' @title  Screen transcript models by a random forest classifier trained on
#'         known transcripts
#'
#' @param  in_bedv
#'         A vector of BED file(s) for histone marks and/or RNA Pol II
#'         ChIP-seq alignments.  Each BED file is required to have at least
#'         three columns describing chromosome names, starting and
#'         ending positions. Do not include header in BED files.
#'
#' @param  training_tpms
#'         A vector of RSEM quantification result file(s) at the
#'         isoform level.  It is required to have two columns named
#'         'transcript_id' and 'TPM' to define the abundances of
#'         training transcripts.  This file is the one with a suffix
#'         '.isoforms.results' generated by RSEM. Header is required.
#'
#' @param  training_gtf
#'         A GTF file that defines the genomic coordinates and features
#'         for all training transcripts.  This file is required to have 'exon'
#'         in the feature column (the 3rd column) and 'transcript_id' entry in
#'         the attribute column (the 9th column).
#'
#' @param  testing_gtf
#'         Name of a GTF file defining the genomic coordiantes and features
#'         for transcript models to be screened.  GTF files generated by
#'         PRAM's buildModel() function can be used here directly.
#'
#' @param  out_gtf
#'         Name of a GTF file to save transcripts selected by the classifier
#'
#' @param  tmpdir
#'         Name of a temporary directory to save four files:
#'         \itemize{
#'             \item 'rf.rda' for an R random forest classifier
#'             \item 'roc_pr.pdf' plots ROC and precision-recall curves
#'                   from cross validation
#'             \item 'cv.tsv' saved the prediction results on training
#'                   transcript from cross validation.
#'             \item 'pred.tsv' saved the prediction results testing transcripts
#'         }
#'         File with the same name in this folder will be overwritten.
#'         Default: NULL
#'
#' @param  expr_min_tpm
#'         A numeric value of minimium TPM for a transcript to be defined as
#'         expressed.  An 'expressed' or 'unexpressed'
#'         transcript must have TPM >= or < this cutoff in all
#'         supplied RSEM quantification files (ftpms),
#'         respectively.  Otherwise, a transcript's expression
#'         status will be defined as 'indeterminate'.  Transcripts with
#'         'indeterminate' expression status will be omitted from the
#'         training and output files.
#'         Default: 1
#'
#' @param  cv_n_folds  An integer of folds for cross validation. 'Expressed' and
#'                     'unexpressed' training transcripts will be stratified
#'                     for calculating AUC.
#'                     Default: 10
#'
#' @param  nthreads  An integer defining the number of threads to-be-used.
#'                   An ideal number would be equal to the maximum one of
#'                   cv_n_folds and number of input BED files. Default: 1
#'
#' @return  NULL
#'
#' @export
#'
#' @examples
#'
#' fbeds = c( system.file('extdata/bed/GM12878POLR2AphosphoS5Rep1.bed',
#'                        package='pram'),
#'            system.file('extdata/bed/GM12878POLR2AphosphoS5Rep2.bed',
#'                        package='pram') )
#'
#' ftpms = c( system.file('extdata/rsem/GM12878Rep1_training.isoforms.results',
#'                        package='pram'),
#'            system.file('extdata/rsem/GM12878Rep2_training.isoforms.results',
#'                        package='pram') )
#'
#' fgtf_training = system.file('extdata/gtf/rf_training.gtf', package='pram')
#' fgtf_testing  = system.file('extdata/gtf/rf_testing.gtf',  package='pram')
#'
#' fgtf_out = tempfile(fileext='.gtf')
#'
#' screenModel(fbeds, ftpms, fgtf_training, fgtf_testing, fgtf_out)
#'
#'
screenModel <- function(in_bedv, training_tpms, training_gtf,
                        testing_gtf, out_gtf,
                        tmpdir=NULL, expr_min_tpm=1, cv_n_folds=10, nthreads=1){

    fbeds = in_bedv
    ftpms = training_tpms
    fgtf_training = training_gtf
    fgtf_testing  = testing_gtf
    fgtf_out      = out_gtf

    trainl = trainModelClassifier(fbeds, ftpms, fgtf_training, tmpdir,
                                  expr_min_tpm, cv_n_folds, nthreads)

    outgtf = screenModelByRF(trainl$rf, trainl$beddt, fgtf_testing, tmpdir,
                             nthreads)

    writeGTF(outgtf, fgtf_out, append=F)
}


screenModelByRF <- function(rf, beddt, fgtf_testing, tmpdir, nthreads) {
    prm = new('Param')

    gtf = new('GTF')
    gtf = initFromGTFFile(gtf, fgtf_testing, infokeys = c('transcript_id'))
    trdt = getTrGRanges(gtf)

    locgrs = defUpDownStream(trdt, tsstesextwidth(prm))

    rpkmdt = calRPKM(beddt, locgrs, nthreads)

    wide_rpkmdt = dcast(rpkmdt, trid ~ chipseqid + loc, value.var='rpkm')
    pred_resp = predict(rf, wide_rpkmdt, type='response')
    pred_prob = predict(rf, wide_rpkmdt, type='prob')

    outdt = data.table( trid = wide_rpkmdt$trid,
                        resp = pred_resp,
                        prob = pred_prob[, 'expressed'] )

    if ( ! is.null(tmpdir) ) {
        if( ! file.exists(tmpdir) ) dir.create(tmpdir, recursive=T)

        fout = paste0(tmpdir, 'pred.tsv')
        write.table(outdt, fout, quote=F, sep="\t", row.names=F)
    }

    sel_trids = outdt[ resp == 'expressed' ]$trid
    grdt = grangedt(gtf)
    sel_grdt = grdt[ transcript_id %in% sel_trids ]

    outgtf = new('GTF')
    outgtf = initFromDataTable(outgtf, sel_grdt, c('transcript_id'),
                               origin='PRAM_RF')

    return(outgtf)
}


#' Train a random forest classifier to filter transcript models
#'
#' @inheritParams  screenModel
#'
#' @param  fgtf  A string of a GTF file defining the genomic coordinates for
#'               all training transcripts.  The file is required for have 'exon'
#'               in the feature column, where transcript coordinates will be
#'               derived.
#'
#' @return  A list contains:
#'          \itemize{
#'              \item 'rf': a trained random forest object
#'              \item 'beddt': a data.table of processed ChIP-seq data
#'          }
#'
#' @export
#'
trainModelClassifier <- function(fbeds, ftpms, fgtf, tmpdir=NULL,
                                 expr_min_tpm=1, cv_n_folds=10, nthreads=1) {
    prm = new('Param')

    beddt = processBEDs(fbeds, nthreads, chipseqmaxndupaln(prm))

    gtf = new('GTF')
    gtf = initFromGTFFile(gtf, fgtf, infokeys = c('transcript_id'))

    trdt = getTrGRanges(gtf)

    tpmdt = processTPMs(ftpms, nthreads, expr_min_tpm, trdt$trid)

    locgrs = defUpDownStream(trdt, tsstesextwidth(prm))

    rpkmdt = calRPKM(beddt, locgrs, nthreads)

    outl = trainRF(rpkmdt, tpmdt, cv_n_folds, nthreads, fout_rf, fout_cv,
                   fpdf_rocpr, randomseed(prm))

    if ( ! is.null(tmpdir) ) {
        if ( ! file.exists(tmpdir) ) dir.create(tmpdir, recursive=T)

        fout_rf    = paste0(tmpdir, 'rf.rda')
        fout_cv    = paste0(tmpdir, 'cv.tsv')
        fpdf_rocpr = paste0(tmpdir, 'roc_pr.pdf')

        rf = outl$rf
        save(rf, file=fout_rf)

        write.table(outl$allcvdt, fout_cv, quote=F, sep="\t", row.names=F)

        plotRocPr(outl$allcvdt, fpdf_rocpr)
    }

    outlist = list( rf    = outl$rf,
                    beddt = beddt )

    return(outlist)
}


#' @importFrom  caret  createFolds
#' @importFrom  parallel mclapply
#'
trainRF <- function(rpkmdt, tpmdt, nfolds, nthr, fout_rf, fout_cv, fpdf_rocpr,
                    random_seed) {
    set.seed(random_seed)

    groupdt = tpmdt[ is_expr != 'indeterminate' ]
    group = createFolds(groupdt$is_expr, k=nfolds, list=F)
    groupdt = cbind(groupdt, group)

    wide_rpkmdt = dcast(rpkmdt, trid ~ chipseqid + loc, value.var='rpkm')
    mrgdt = merge(groupdt, wide_rpkmdt, by='trid', all.x=T)
    feature_names = setdiff(names(mrgdt), c('trid', 'is_expr', 'group'))
    resp_name = 'is_expr'

    if ( nthr == 1 ) {
        cvdt = rbindlist(lapply(1:nfolds, doCVByFold, mrgdt, feature_names,
                                resp_name))
    } else if ( nthr > 1 ) {
        cvdt = rbindlist(mclapply(1:nfolds, doCVByFold, mrgdt, feature_names,
                                  resp_name, mc.cores=nthr))
    }
    indeterminatedt = tpmdt[ is_expr == 'indeterminate' ]
    indeterminatedt[, `:=`(group = NA, prob_is_expr = NA)]
    out_cvdt = rbind(cvdt, indeterminatedt)

    rf = trainByRF(mrgdt, feature_names, resp_name)

    outl = list( rf      = rf,
                 allcvdt = out_cvdt )

    return(outl)
}


#' @importFrom  ROCR     prediction performance
#' @importFrom  ggplot2  geom_line aes theme_bw theme xlim ylim ggplot geom_abline ggtitle coord_cartesian element_text
#'
plotRocPr <- function(indt, fpdf) {
    is_expr_levels = c('unexpressed', 'expressed')
    cvdt = indt[ is_expr %in% is_expr_levels]
    cvdt[, is_expr := factor(is_expr, levels=is_expr_levels)]

    pred_obj = prediction(cvdt$prob_is_expr, as.integer(cvdt$is_expr))
    perf_roc = performance(pred_obj, measure='tpr',  x.measure='fpr')
    perf_pr  = performance(pred_obj, measure='prec', x.measure='rec')
    perf_auc = performance(pred_obj, measure='auc')
    auc = perf_auc@y.values[[1]]
    if ( length( perf_roc@alpha.values[[1]] ) !=
         length( perf_pr@alpha.values[[1]]  )  ){
        stop("cutoffs for ROC and PR are not equal\n")
    }

    pltdt = data.table( cutoff    = perf_roc@alpha.values[[1]],
                        FPR       = perf_roc@x.values[[1]],
                        TPR       = perf_roc@y.values[[1]],
                        recall    = perf_pr@x.values[[1]],
                        precision = perf_pr@y.values[[1]] )

    rocp = ggplot(pltdt, aes(x=FPR, y=TPR)) +
           geom_abline(slope=1, intercept=0, linetype='dashed', size=0.3) +
           ggtitle( paste0('AUC=', round(auc, digits=3)) ) +
           geom_line() +
           theme_bw() +
           theme( aspect.ratio = 1,
                  plot.title   = element_text(hjust=0.5) ) +
           coord_cartesian( xlim=c(0, 1),  ylim=c(0, 1) )

    prp  = ggplot(pltdt[ ! is.na(precision) ], aes(x=recall, y=precision)) +
           geom_line() +
           theme_bw() +
           theme( aspect.ratio = 1 ) +
           coord_cartesian( xlim=c(0, 1),  ylim=c(0, 1) )

    pdf(fpdf, width=3, height=3)
    print(rocp)
    print(prp)
    dev.off()
   #cat('Figure plotted:', fpdf, "\n")
}


doCVByFold <- function(ifold, indt, feature_names, resp_name) {
    traindt = indt[ group != ifold ]
    testdt  = indt[ group == ifold ]

    rf_model = trainByRF(traindt, feature_names, resp_name)

    test_inpmat = data.matrix(testdt[, feature_names, with=F])

    predmat = predict(rf_model, test_inpmat, type='prob')

    outdt = data.table( group   = ifold,
                        trid    = testdt$trid,
                        ## unexpressed must < expressed when return prob_expr
                        is_expr = factor(testdt$is_expr,
                                         levels=c('unexpressed', 'expressed')),
                        prob_is_expr = predmat[, 'expressed'] )

    return(outdt)
}


#' @importFrom  randomForest  randomForest
#'
trainByRF <- function(traindt, feature_names, resp_name) {
    inpmat = data.matrix(traindt[, feature_names, with=F])
    resp = factor(traindt[[resp_name]])
    mdl = randomForest(x=inpmat, y=resp)
    return(mdl)
}


#' @importFrom  parallel  mclapply
#'
calRPKM <- function(beddt, locgrs, nthr) {
    chipseqids = unique(beddt$chipseqid)
    rpkmdt = data.table()
    if ( nthr == 1 ) {
        rpkmdt = rbindlist(lapply(chipseqids, calRPKMByChIPSeqID, beddt,
                                  locgrs))
    } else if ( nthr > 1 ) {
        rpkmdt = rbindlist(mclapply(chipseqids, calRPKMByChIPSeqID, beddt,
                                    locgrs, mc.cores=nthr))
    }

    return(rpkmdt)
}


calRPKMByChIPSeqID <- function(in_chipseqid, beddt, locgrs) {
    chipseqdt = beddt[chipseqid == in_chipseqid]
    chipseqgrs = makeGRangesFromDataFrame(chipseqdt, keep.extra.columns=T)

    nrds = nrow(chipseqdt)

    ol = findOverlaps(chipseqgrs, locgrs, type='within', ignore.strand=T)
    oldt = data.table(as.data.frame(ol))
    oldt[, `:=`( trid = locgrs$trid[subjectHits],
                 loc  = locgrs$loc[subjectHits] )]

    noldt = oldt[, list(nol = .N), by=list(trid, loc)]

    locdt = data.table(as.data.frame(locgrs))
    mrgdt = merge(locdt, noldt, by=c('trid', 'loc'), all.x=T)
    mrgdt[, nol := ifelse(is.na(nol), 0, nol)]

    one_billion = 1e+9
    mrgdt[, `:=`( rpkm = nol * one_billion/nrds/width,
                  chipseqid = in_chipseqid ) ]

    outdt = mrgdt[, .(trid, loc, rpkm, chipseqid)]

    return(outdt)
}


defUpDownStream <- function(trdt, ext_width) {
    trdt[, `:=`(
        upstream_start   = ifelse(strand == '+', start - ext_width,
                                  ifelse(strand == '-', end + 1, NA)),
        upstream_end     = ifelse(strand == '+', start - 1,
                                  ifelse(strand == '-', end + ext_width,
                                         NA)),
        downstream_start = ifelse(strand == '+', end + 1,
                                  ifelse(strand == '-', start - ext_width,
                                         NA)),
        downstream_end   = ifelse(strand == '+', end + ext_width,
                                  ifelse(strand == '-', start - 1, NA))
    )]

    bodygrs = makeGRangesFromDataFrame(
        trdt[, list(trid, chrom, start, end, strand)],
        keep.extra.columns=T)

    upstreamgrs = makeGRangesFromDataFrame(
        trdt[, list(trid, chrom, upstream_start, upstream_end, strand)],
        start.field = 'upstream_start', end.field = 'upstream_end',
        keep.extra.columns=T)

    downstreamgrs = makeGRangesFromDataFrame(
        trdt[, list(trid, chrom, downstream_start, downstream_end, strand)],
        start.field = 'downstream_start', end.field = 'downstream_end',
        keep.extra.columns=T)

    bodygrs$loc       = 'body'
    upstreamgrs$loc   = 'upstream'
    downstreamgrs$loc = 'downstream'

    outgrs = c(upstreamgrs, bodygrs, downstreamgrs)

    return(outgrs)
}


getTrGRanges <- function(gtf) {
    exondt = grangedt(gtf)[ feature == 'exon' ]
    setnames(exondt, 'transcript_id', 'trid')
    trdt = exondt[, list( chrom  = unique(chrom),
                          start  = min(start),
                          end    = max(end),
                          strand = unique(strand) ), by=trid]

    return(trdt)
}


#' @importFrom  parallel  mclapply
#'
processTPMs <- function(ftpms, nthr, expr_min_tpm, trids) {
    tpmdt = data.table()
    if ( nthr == 1 ) {
        tpmdt = rbindlist(lapply(ftpms, readTPM, expr_min_tpm, trids))
    } else if ( nthr > 1 ) {
        tpmdt = rbindlist(mclapply(ftpms, readTPM, expr_min_tpm, trids,
                                   mc.cores=nthr))
    }

    nexprdt = tpmdt[, list(nexpr = sum(is_expr)), by=trid]
    expr_trids     = nexprdt[ nexpr == length(ftpms) ]$trid
    not_expr_trids = nexprdt[ nexpr == 0 ]$trid
    outdt = data.table( trid = nexprdt$trid )

    ## required characters, not numbers, for createFolds stratification
    outdt[, is_expr := ifelse(trid %in% expr_trids, 'expressed',
                              ifelse(trid %in% not_expr_trids, 'unexpressed',
                                     'indeterminate'))]

    return(outdt)
}


#' @importFrom  tools  file_path_sans_ext
#'
readTPM <- function(ftpm, expr_min_tpm, trids) {
    rnaseqid = file_path_sans_ext(basename(ftpm))
    tpmdt = fread(ftpm, header=T, sep="\t", select=c('transcript_id', 'TPM'),
                  showProgress=F)
    setnames(tpmdt, c('trid', 'tpm'))

    non_trids = setdiff(trids, tpmdt$trid)
    if ( length(non_trids) > 0 ) {
        msg = paste0('The following training transcript_id not found in ',
                     ftpm, "\n", paste0(non_trids, collapse=','), "\n")
        warnings(msg)
    }

    outdt = tpmdt[ trid %in% trids ]
    outdt[, `:=`( rnaseqid = rnaseqid,
                  is_expr  = ifelse(tpm >= expr_min_tpm, 1, 0) )]

    return(outdt)
}


#' @importFrom  parallel  mclapply
#'
processBEDs <- function(fbeds, nthr, max_n_aln) {
    beddt = data.table()
    if ( nthr == 1 ) {
        beddt = rbindlist(lapply(fbeds, readCapBed, max_n_aln))
    } else if ( nthr > 1 ) {
        beddt = rbindlist(mclapply(fbeds, readCapBed, max_n_aln, mc.cores=nthr))
    }

    return(beddt)
}


#' @importFrom  tools  file_path_sans_ext
#'
readCapBed <- function(fbed, max_n_aln) {
    chipseqid = file_path_sans_ext(basename(fbed))
    beddt = data.table(read.table(fbed, header=F, sep="\t"))
    setnames(beddt, c('V1', 'V2', 'V3'), c('chrom', 'start', 'end'))
    beddt[, dupi := seq_len(.N), by=list(chrom, start, end)]

    outdt = beddt[ dupi <= max_n_aln ]
    outdt[, `:=`( dupi = NULL,
                  chipseqid = chipseqid ) ]

    return(outdt)
}
