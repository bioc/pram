#' Train a random forest classifier to filter transcript models
#'
#' @param  fbeds  A string vector of BED files for histone marks and/or RNA
#'                Pol II ChIP-seq signals in RPKM.  They are required to have
#'                at least three columns describing the names of chromosome,
#'                starting and ending positions, and strand.
#'
#' @param  ftpms  A string vector of RSEM quantification results at the
#'                isoform level.  It is required to have two columns named
#'                'transcript_id' and 'TPM' to define the abundances of
#'                training transcripts.  This file is the one with a suffix
#'                '.isoforms.results' generated by RSEM.
#'
#' @param  fgtf  A string of a GTF file defining the genomic coordinates for
#'               all training transcripts.  The file is required for have 'exon'
#'               in the feature column, where transcript coordinates will be
#'               derived.
#'
#' @param  outdir  A string of a directory to save three output files: 'rf.rda'
#'                 for a random forest R object, 'roc_pr.pdf' plots ROC and
#'                 precision-recall curves from cross validation,
#'                 and 'cv.tsv' saved the prediction
#'                 results on training transcript from cross validation.  Files
#'                 with the same names in this folder will be overwritten.
#'
#' @param  expr_min_tpm  Minimium TPM for a transcript to be defined as
#'                       expressed.  An 'expressed' or 'unexpressed'
#'                       transcript must have TPM >= or < this cutoff in all
#'                       supplied RSEM quantification files (ftpms),
#'                       respectively.  Otherwise, a transcript's expression
#'                       status will be defined as 'unknown'.  Transcripts with
#'                       'unknown' expression status will be omitted from the
#'                       training and output files.  Default: 1.
#'
#' @param  cv_n_folds  Number of folds for cross validation.  'Expressed' and
#'                     'unexpressed' training transcripts will be stratified
#'                     for calculating AUC.  Default: 10.
#'
#' @param  nthreads  An integer defining the number of threads to-be-used.
#'                   Default: 1
#'
#' @return  NULL
#'
#' @export
#'
trainModelFilter <- function(fbeds, ftpms, fgtf, outdir, expr_min_tpm=1,
                             cv_n_folds=10, nthreads=1) {
    prm = new('Param')

    beddt = processBEDs(fbeds, nthreads, chipseqmaxndupaln(prm))

    tpmdt = processTPMs(ftpms, nthreads, expr_min_tpm)

    trdt = getTrGRanges(fgtf)

    locgrs = defUpDownStream(trdt, tsstesextwidth(prm))

    rpkmdt = calRPKM(beddt, locgrs, nthreads)

    if ( ! file.exists(outdir) ) dir.create(outdir)
    fout_rf    = paste0(outdir, 'rf.rda')
    fout_cv    = paste0(outdir, 'cv.tsv')
    fpdf_rocpr = paste0(outdir, 'roc_pr.pdf')
    trainRF(rpkmdt, tpmdt, cv_n_folds, nthreads, fout_rf, fout_cv, fpdf_rocpr)
}


#' @importFrom  caret  createFolds
#'
trainRF <- function(rpkmdt, tpmdt, nfolds, nthr, fout_rf, fout_cv, fpdf_rocpr) {
    set.seed(88888888)

    groupdt = tpmdt[ is_expr != 'unknown' ]
    group = createFolds(groupdt$is_expr, k=nfolds, list=F)
    groupdt = cbind(groupdt, group)

    wide_rpkmdt = dcast(rpkmdt, trid ~ chipseqid + loc, value.var='rpkm')
    mrgdt = merge(groupdt, wide_rpkmdt, by='trid', all.x=T)
    feature_names = setdiff(names(mrgdt), c('trid', 'is_expr', 'group'))
    resp_name = 'is_expr'

    if ( nthr == 1 ) {
        cvdt = rbindlist(lapply(1:nfolds, doCVByFold, mrgdt, feature_names,
                                resp_name))
    } else if ( nthr > 1 ) {
        cvdt = rbindlist(mclapply(1:nfolds, doCVByFold, mrgdt, feature_names,
                                  resp_name, mc.cores=nthr))
    }
    unknowndt = tpmdt[ is_expr == 'unknown' ]
    unknowndt[, `:=`(group = NA, prob_is_expr = NA)]
    out_cvdt = rbind(cvdt, unknowndt)
    write.table(out_cvdt, fout_cv, quote=F, sep="\t", row.names=F)
    cat('File written:', fout_cv, "\n")

    plotRocPr(cvdt, fpdf_rocpr)

    rf = trainByRF(mrgdt, feature_names, resp_name)
    save(rf, file=fout_rf)
    cat('R object saved:', fout_rf, "\n")
}


#' @importFrom  ROCR     prediction performance
#' @importFrom  ggplot2  geom_line aes theme_bw theme xlim ylim ggplot geom_abline ggtitle coord_cartesian element_text
#'
plotRocPr <- function(cvdt, fpdf) {
    pred_obj = prediction(cvdt$prob_is_expr, as.integer(cvdt$is_expr))
    perf_roc = performance(pred_obj, measure='tpr',  x.measure='fpr')
    perf_pr  = performance(pred_obj, measure='prec', x.measure='rec')
    perf_auc = performance(pred_obj, measure='auc')
    auc = perf_auc@y.values[[1]]
    if ( length( perf_roc@alpha.values[[1]] ) !=
         length( perf_pr@alpha.values[[1]]  )  ){
        stop("cutoffs for ROC and PR are not equal\n")
    }

    pltdt = data.table( cutoff    = perf_roc@alpha.values[[1]],
                        FPR       = perf_roc@x.values[[1]],
                        TPR       = perf_roc@y.values[[1]],
                        recall    = perf_pr@x.values[[1]],
                        precision = perf_pr@y.values[[1]] )

    rocp = ggplot(pltdt, aes(x=FPR, y=TPR)) +
           geom_abline(slope=1, intercept=0, linetype='dashed', size=0.3) +
           ggtitle( paste0('AUC=', round(auc, digits=3)) ) +
           geom_line() +
           theme_bw() +
           theme( aspect.ratio = 1,
                  plot.title   = element_text(hjust=0.5) ) +
           coord_cartesian( xlim=c(0, 1),  ylim=c(0, 1) )

    prp  = ggplot(pltdt[ ! is.na(precision) ], aes(x=recall, y=precision)) +
           geom_line() +
           theme_bw() +
           theme( aspect.ratio = 1 ) +
           coord_cartesian( xlim=c(0, 1),  ylim=c(0, 1) )

    pdf(fpdf, width=3, height=3)
    print(rocp)
    print(prp)
    dev.off()
    cat('Figure plotted:', fpdf, "\n")
}


doCVByFold <- function(ifold, indt, feature_names, resp_name) {
    traindt = indt[ group != ifold ]
    testdt  = indt[ group == ifold ]

    rf_model = trainByRF(traindt, feature_names, resp_name)

    test_inpmat = data.matrix(testdt[, feature_names, with=F])

    predmat = predict(rf_model, test_inpmat, type='prob')

    outdt = data.table( group   = ifold,
                        trid    = testdt$trid,
                        ## unexpressed must < expressed when return prob_expr
                        is_expr = factor(testdt$is_expr,
                                         levels=c('unexpressed', 'expressed')),
                        prob_is_expr = predmat[, 'expressed'] )

    return(outdt)
}


#' @importFrom  randomForest  randomForest
#'
trainByRF <- function(traindt, feature_names, resp_name) {
    inpmat = data.matrix(traindt[, feature_names, with=F])
    resp = factor(traindt[[resp_name]])
    mdl = randomForest(x=inpmat, y=resp)
    return(mdl)
}


calRPKM <- function(beddt, locgrs, nthr) {
    chipseqids = unique(beddt$chipseqid)
    rpkmdt = data.table()
    if ( nthr == 1 ) {
        rpkmdt = rbindlist(lapply(chipseqids, calRPKMByChIPSeqID, beddt,
                                  locgrs))
    } else if ( nthr > 1 ) {
        rpkmdt = rbindlist(mclapply(chipseqids, calRPKMByChIPSeqID, beddt,
                                    locgrs, mc.cores=nthr))
    }

    return(rpkmdt)
}


calRPKMByChIPSeqID <- function(in_chipseqid, beddt, locgrs) {
    chipseqdt = beddt[chipseqid == in_chipseqid]
    chipseqgrs = makeGRangesFromDataFrame(chipseqdt, keep.extra.columns=T)

    nrds = nrow(chipseqdt)

    ol = findOverlaps(chipseqgrs, locgrs, type='within', ignore.strand=T)
    oldt = data.table(as.data.frame(ol))
    oldt[, `:=`( trid = locgrs$trid[subjectHits],
                 loc  = locgrs$loc[subjectHits] )]

    noldt = oldt[, list(nol = .N), by=list(trid, loc)]

    locdt = data.table(as.data.frame(locgrs))
    mrgdt = merge(locdt, noldt, by=c('trid', 'loc'), all.x=T)
    mrgdt[, nol := ifelse(is.na(nol), 0, nol)]

    one_billion = 1e+9
    mrgdt[, `:=`( rpkm = nol * one_billion/nrds/width,
                  chipseqid = in_chipseqid ) ]

    outdt = mrgdt[, .(trid, loc, rpkm, chipseqid)]

    return(outdt)
}


defUpDownStream <- function(trdt, ext_width) {
    trdt[, `:=`(
        upstream_start   = ifelse(strand == '+', start - ext_width,
                                  ifelse(strand == '-', end + 1, NA)),
        upstream_end     = ifelse(strand == '+', start - 1,
                                  ifelse(strand == '-', end + ext_width,
                                         NA)),
        downstream_start = ifelse(strand == '+', end + 1,
                                  ifelse(strand == '-', start - ext_width,
                                         NA)),
        downstream_end   = ifelse(strand == '+', end + ext_width,
                                  ifelse(strand == '-', start - 1, NA))
    )]

    bodygrs = makeGRangesFromDataFrame(
        trdt[, list(trid, chrom, start, end, strand)],
        keep.extra.columns=T)

    upstreamgrs = makeGRangesFromDataFrame(
        trdt[, list(trid, chrom, upstream_start, upstream_end, strand)],
        start.field = 'upstream_start', end.field = 'upstream_end',
        keep.extra.columns=T)

    downstreamgrs = makeGRangesFromDataFrame(
        trdt[, list(trid, chrom, downstream_start, downstream_end, strand)],
        start.field = 'downstream_start', end.field = 'downstream_end',
        keep.extra.columns=T)

    bodygrs$loc       = 'body'
    upstreamgrs$loc   = 'upstream'
    downstreamgrs$loc = 'downstream'

    outgrs = c(upstreamgrs, bodygrs, downstreamgrs)

    return(outgrs)
}


getTrGRanges <- function(fgtf) {
    gtf = new('GTF')
    gtf = initFromGTFFile(gtf, fgtf, infokeys = c('transcript_id'))
    exondt = grangedt(gtf)[ feature == 'exon' ]
    setnames(exondt, 'transcript_id', 'trid')
    trdt = exondt[, list( chrom  = unique(chrom),
                          start  = min(start),
                          end    = max(end),
                          strand = unique(strand) ), by=trid]

    return(trdt)
}


processTPMs <- function(ftpms, nthr, expr_min_tpm) {
    tpmdt = data.table()
    if ( nthr == 1 ) {
        tpmdt = rbindlist(lapply(ftpms, readTPM, expr_min_tpm))
    } else if ( nthr > 1 ) {
        tpmdt = rbindlist(mclapply(ftpms, readTPM, expr_min_tpm))
    }

    nexprdt = tpmdt[, list(nexpr = sum(is_expr)), by=trid]
    expr_trids     = nexprdt[ nexpr == length(ftpms) ]$trid
    not_expr_trids = nexprdt[ nexpr == 0 ]$trid
    outdt = data.table( trid = nexprdt$trid )

    ## required characters, not numbers, for createFolds stratification
    outdt[, is_expr := ifelse(trid %in% expr_trids, 'expressed',
                              ifelse(trid %in% not_expr_trids, 'unexpressed',
                                     'unknown'))]

    return(outdt)
}


#' @importFrom  tools  file_path_sans_ext
#'
readTPM <- function(ftpm, expr_min_tpm) {
    rnaseqid = file_path_sans_ext(basename(ftpm))
    tpmdt = fread(ftpm, header=T, sep="\t", select=c('transcript_id', 'TPM'),
                  showProgress=F)
    setnames(tpmdt, c('trid', 'tpm'))
    tpmdt[, `:=`( rnaseqid = rnaseqid,
                  is_expr  = ifelse(tpm >= expr_min_tpm, 1, 0) )]

    return(tpmdt)
}


processBEDs <- function(fbeds, nthr, max_n_aln) {
    beddt = data.table()
    if ( nthr == 1 ) {
        beddt = rbindlist(lapply(fbeds, readCapBed, max_n_aln))
    } else if ( nthr > 1 ) {
        beddt = rbindlist(mclapply(fbeds, readCapBed, man_n_aln))
    }

    return(beddt)
}


#' @importFrom  tools  file_path_sans_ext
#'
readCapBed <- function(fbed, max_n_aln) {
    chipseqid = file_path_sans_ext(basename(fbed))
    beddt = fread(fbed, header=F, sep="\t", showProgress=F)
    setnames(beddt, c('V1', 'V2', 'V3'), c('chrom', 'start', 'end'))
    beddt[, dupi := seq_len(.N), by=list(chrom, start, end)]

    outdt = beddt[ dupi <= max_n_aln ]
    outdt[, `:=`( dupi = NULL,
                  chipseqid = chipseqid ) ]

    return(outdt)
}
