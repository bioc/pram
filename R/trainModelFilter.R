#' Train a random forest classifier to filter transcript models
#'
#' @param  fbeds  A string vector of BED files for histone marks and/or RNA
#'                Pol II ChIP-seq signals in RPKM.  They are required to have
#'                at least three columns describing the names of chromosome,
#'                starting and ending positions, and strand.
#'
#' @param  ftpms  A string vector of RSEM quantification results at the
#'                isoform level.  It is required to have two columns named
#'                'transcript_id' and 'TPM' to define the abundances of
#'                training transcripts.  This file is the one with a suffix
#'                '.isoforms.results' generated by RSEM.
#'
#' @param  fgtf  A string of a GTF file defining the genomic coordinates for
#'               all training transcripts
#'
#' @param  expr_min_tpm  Minimium TPM for a transcript to be defined as
#'                       expressed.  If multiple RSEM quantification files are
#'                       provided, a transcript wll be defined as 'expressed'
#'                       if its abundances are higher or equal to this
#'                       minimium TPM in all quantification files.  Default: 1.
#'
#' @param  nthreads  an integer defining the number of threads to-be-used.
#'                   Default: 1
#'
#' @return  A random forest classifier object from package randomForest.
#'
#' @export
#'
trainModelFilter <- function(fbeds, ftpms, fgtf, expr_min_tpm=1, nthreads=1) {
    prm = new('Param')
    exprmintpm(prm) = expr_min_tpm
    nthreads(prm) = nthreads

    beddt = processBEDs(fbeds, nthreads, prm)
    tpmdt = processTPMs(ftpms, nthreads, expr_min_tpm)

    gtf = new('GTF')
    gtf = initFromGTFFile(gtf, fgtf, infokeys = c('transcript_id'))

    browser()
}


processTPMs <- function(ftpms, nthr, expr_min_tpm) {
    tpmdt = data.table()
    if ( nthr == 1 ) {
        tpmdt = rbindlist(lapply(ftpms, readTPM, expr_min_tpm))
    } else if ( nthr > 1 ) {
        tpmdt = rbindlist(mclapply(ftpms, readTPM, expr_min_tpm))
    }

    nexprdt = tpmdt[, list(nexpr = sum(is_expr)), by=trid]
    expr_trids = nexprdt[ nexpr == length(ftpms)]$trid
    outdt = data.table( trid = nexprdt$trid )
    outdt[, is_expr := ifelse(trid %in% expr_trids, 1, 0)]

    return(outdt)
}


#' @importFrom  tools  file_path_sans_ext
#'
readTPM <- function(ftpm, expr_min_tpm) {
    rnaseqid = file_path_sans_ext(basename(ftpm))
    tpmdt = fread(ftpm, header=T, sep="\t", select=c('transcript_id', 'TPM'),
                  showProgress=F)
    setnames(tpmdt, c('trid', 'tpm'))
    tpmdt[, `:=`( rnaseqid = rnaseqid
                  is_expr  = ifelse(tpm >= expr_min_tpm, 1, 0) )]

    return(tpmdt)
}


processBEDs <- function(fbeds, nthr, prm) {
    beddt = data.table()
    if ( nthr == 1 ) {
        beddt = rbindlist(lapply(fbeds, readCapBed, prm))
    } else if ( nthr > 1 ) {
        beddt = rbindlist(mclapply(fbeds, readCapBed, prm))
    }

    return(beddt)
}


#' @importFrom  tools  file_path_sans_ext
#'
readCapBed <- function(fbed, prm) {
    chipseqid = file_path_sans_ext(basename(fbed))
    beddt = fread(fbed, header=F, sep="\t", showProgress=F)
    setnames(beddt, c('V1', 'V2', 'V3'), c('chrom', 'start', 'end'))
    beddt[, dupi := seq_len(.N), by=list(chrom, start, end)]

    outdt = beddt[ dupi <= chipseqmaxnaln(prm) ]
    outdt[, `:=`( dupi = NULL,
                  chipseqid = chipseqid ) ]

    return(outdt)
}
